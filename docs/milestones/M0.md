# M0: Toolchain + Build Skeleton

## Goal
Establish a working toolchain and a minimal build/run/test skeleton.

## Accomplished
- Built and verified the `x86_64-elf` cross-compiler toolchain (binutils + GCC) and validated with `tests/test_toolchain.sh`.
- Implemented a Multiboot2 header in `kernel/entry.S` with the required fields:
  - Magic `0xE85250D6`
  - Architecture `0` (i386)
  - Header length and checksum (so the sum is zero)
  - End tag (`type=0`, `size=8`)
- Added a 32-bit entry point (`start`) that disables interrupts, sets a 4 KiB stack in `.bss`, and halts in a loop.
- Added a linker script `kernel/linker.ld` that:
  - Sets the load address to 1 MiB (`. = 1M;`)
  - Places `.multiboot2` first so GRUB can find it early in the file
  - Lays out `.text`, `.rodata`, `.data`, and `.bss` in order
- Added `boot/grub.cfg` with a single GRUB2 menu entry using `multiboot2 /boot/kernel.elf`.
- Created a minimal build pipeline in `Makefile`:
  - `make kernel`: assemble `kernel/entry.S` and link `build/kernel.elf` (ELF32 i386)
  - `make iso`: package the kernel into `build/vibeos.iso` using `grub-mkrescue`
  - `make run`: launch QEMU headless with `-display none -serial stdio`
  - `make clean`: remove `build/`
- Added a build test `tests/test_build.sh` that runs `make clean` + `make kernel` and checks `build/kernel.elf` exists.
- Verified ISO creation and headless QEMU boot; no serial output yet because the kernel only halts.

## Key Takeaways
- The linker script controls *where* the kernel lives in memory and the order of sections.
- The Multiboot2 header is how GRUB recognizes the kernel and decides how to load it.
- The early entry point can be minimal as long as the stack is valid and the CPU doesnâ€™t fall off into random memory.
- Headless QEMU with serial output is sufficient for early OS bring-up and testing.

## Evidence
- `tests/test_toolchain.sh` passes.
- `tests/test_build.sh` passes.
- `make iso` succeeds.
- `make run` boots headless (no output yet because the kernel only halts).
